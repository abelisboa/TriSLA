Você é um agente do Cursor especializado em:

Arquiteturas em microserviços e APIs REST;

Integração de frontends e backends com serviços externos via HTTP;

Python/FastAPI (backend) e TypeScript/React (frontend);

Engenharia de confiabilidade (timeouts, retries, health-checks, logs);

Ambientes híbridos: Portal local consumindo serviços remotos via kubectl port-forward.

O contexto é o seguinte:

O NASP TriSLA está rodando remotamente (cluster Kubernetes).

Os módulos do TriSLA no namespace trisla são expostos para o Portal via port-forward no node1:

trisla-sem-csmf → localhost:8080

trisla-ml-nsmf → localhost:8081

trisla-decision-engine→ localhost:8082

trisla-bc-nssmf → localhost:8083

trisla-sla-agent-layer→ localhost:8084

O Portal roda localmente em:

Backend: http://localhost:8001

Frontend (UI): outro processo separado.

O backend já faz chamadas como:

POST http://localhost:8080/api/v1/intents

POST http://localhost:8081/api/v1/predict

POST http://localhost:8082/api/v1/decide

POST http://localhost:8083/api/v1/register-sla

No NASP, o BC-NSSMF e o Besu já estão saudáveis:

/health do trisla-bc-nssmf retorna:

{
  "status": "healthy",
  "module": "bc-nssmf",
  "enabled": true,
  "rpc_connected": true,
  "rpc_error": null
}


Os erros restantes (503, “BC-NSSMF offline”, “RPC Besu não disponível”, “erro de conexão”) são gerados na camada do Portal (timeout, falta de retry, mau tratamento de exceções, ou comportamento frágil frente a oscilações do port-forward).

OBJETIVO GERAL

Refatorar e ajustar o Portal TriSLA (backend +, se necessário, frontend) para que:

Use exclusivamente o NASP como fonte de verdade (nenhuma lógica ou mock local de SEM-CSMF, ML-NSMF, Decision Engine, BC-NSSMF ou SLA-Agent).

Valide e exponha claramente o estado de todos os endpoints NASP usados pelo Portal.

Configure automaticamente os endpoints NASP via variáveis de ambiente, com defaults coerentes com o cenário atual de port-forward local (localhost:8080–8084).

Garanta resiliência para o endpoint /register-sla do BC-NSSMF, com:

timeouts adequados,

retries com backoff,

mensagens de erro claras e diferenciadas (timeout, conexão recusada, 5xx lógico, etc.).

Inicie o Portal Light com diagnóstico automático, verificando conectividade com o NASP e expondo isso em um endpoint de health/diagnostics amigável para o usuário.

REGRAS DE TRABALHO

Não criar mocks locais de NASP ou blockchain.

Se encontrar qualquer flag do tipo USE_MOCK, DEMO_MODE, LOCAL_MODE, MOCK_NASP, desabilitar por padrão, documentando o motivo.

Centralizar toda a configuração de URLs dos serviços NASP em um único módulo de configuração (por exemplo, src/core/config.py ou similar).

Não alterar sem necessidade:

Estrutura de pastas do Portal;

Interface pública dos endpoints do backend (/health, /api/v1/sla/submit, etc.).

Sempre que modificar código:

Manter estilo e padrões existentes (tipagem, logging, convenções).

Adicionar comentários sucintos nos pontos críticos (ex.: tratamento de erro no BC-NSSMF).

Criar tudo de forma que o Portal continue “leve”:

Sem cargas de dados locais pesadas;

Portal apenas orquestra chamadas ao NASP, monta payloads e exibe resultados.

FASE P0 – LEVANTAMENTO E MAPA DO PORTAL

Tarefas:

Localizar a raiz do backend (provavelmente algo como):

trisla-portal/backend/src

Identificar:

Arquivo principal (src/main.py ou similar).

Módulo de configuração (ex.: src/core/config.py).

Serviço que orquestra chamadas ao NASP (ex.: src/services/nasp.py).

Mapear, no código atual, onde são construídas as URLs:

SEM-CSMF: /api/v1/intents

ML-NSMF: /api/v1/predict

Decision: /api/v1/decide

BC-NSSMF: /api/v1/register-sla

SLA-Agent: endpoints que o Portal use (ex.: /api/v1/sla/history, etc.).

Gerar um pequeno resumo (em comentário ou em um README_PORTAL_NASP.md) com:

Arquivo de config.

Onde é feito o binding das URLs.

Quais variáveis de ambiente existem hoje, se houver (ex.: NASP_BASE_URL, SEM_CSMF_URL, etc.).

FASE P1 – CONFIGURAÇÃO AUTOMÁTICA DOS ENDPOINTS (ENV-FIRST)

Objetivo: garantir que todas as URLs de NASP usadas pelo Portal sejam configuráveis via env, com defaults alinhados ao cenário de port-forward local.

Tarefas:

No módulo de configuração, criar (ou consolidar) variáveis como:

# Exemplos – ajuste aos padrões existentes do projeto
NASP_SEM_CSMF_URL      = env("NASP_SEM_CSMF_URL",      default="http://localhost:8080")
NASP_ML_NSMF_URL       = env("NASP_ML_NSMF_URL",       default="http://localhost:8081")
NASP_DECISION_URL      = env("NASP_DECISION_URL",      default="http://localhost:8082")
NASP_BC_NSSMF_URL      = env("NASP_BC_NSSMF_URL",      default="http://localhost:8083")
NASP_SLA_AGENT_URL     = env("NASP_SLA_AGENT_URL",     default="http://localhost:8084")


Refatorar o serviço src/services/nasp.py (ou equivalente) para não concatenar URLs hard-coded, mas utilizar:

sem_csmf_intents_url = f"{settings.NASP_SEM_CSMF_URL}/api/v1/intents"
ml_nsmf_predict_url   = f"{settings.NASP_ML_NSMF_URL}/api/v1/predict"
decision_engine_url   = f"{settings.NASP_DECISION_URL}/api/v1/decide"
bc_register_sla_url   = f"{settings.NASP_BC_NSSMF_URL}/api/v1/register-sla"
sla_agent_url         = f"{settings.NASP_SLA_AGENT_URL}/api/v1/... "


Garantir que não exista nenhum “atajo” do tipo:

BC_NSSMF_URL = "http://localhost:8083"  # EVITAR HARDCODE


Na raiz do backend, definir um arquivo .env.example com todas as variáveis relevantes e comentário explicando que:

No cenário NASP remoto + port-forward local, usar localhost:8080–8084.

Em outros cenários, basta apontar para o IP/hostname do NASP.

FASE P2 – VALIDAÇÃO AUTOMÁTICA DE TODOS OS ENDPOINTS

Objetivo: criar um mecanismo simples no backend do Portal que teste os serviços NASP e exponha isso via API.

Tarefas:

Criar um módulo src/services/nasp_health.py (nome sugestivo) com funções do tipo:

async def check_sem_csmf() -> dict:
    # Faz GET em /health ou uma chamada leve
    # Retorna dict com status, latência, erro, etc.


Fazer isso para:

SEM-CSMF

ML-NSMF

Decision Engine

BC-NSSMF

SLA-Agent (se houver endpoint de health ou pelo menos uma chamada leve)

Em src/main.py (ou no roteador principal), criar um endpoint de diagnóstico:

@app.get("/nasp/diagnostics", response_model=NASPDiagnosticsResponse)
async def nasp_diagnostics():
    """
    Retorna o estado de conectividade entre o Portal e o NASP.
    """


Estrutura sugerida (ajuste ao padrão do projeto):

{
  "sem_csmf":   {"reachable": true,  "latency_ms": 12, "detail": null},
  "ml_nsmf":    {"reachable": true,  "latency_ms": 15, "detail": null},
  "decision":   {"reachable": true,  "latency_ms": 20, "detail": null},
  "bc_nssmf":   {"reachable": true,  "latency_ms": 25, "detail": null},
  "sla_agent":  {"reachable": true,  "latency_ms": 18, "detail": null}
}


Utilizar httpx async com:

Timeout razoável (ex.: 3–5 s).

Captura diferenciada de:

httpx.ConnectError

httpx.ReadTimeout

httpx.HTTPStatusError

Garantir que erros sejam claramente logados (logger do backend) e não quebrem o endpoint: em caso de falha, retornar reachable=false e detail com a mensagem.

FASE P3 – RESILIÊNCIA ESPECÍFICA PARA /register-sla (BC-NSSMF)

Objetivo: tornar a chamada ao BC-NSSMF robusta frente a:

flutuações do kubectl port-forward,

spikes momentâneos de latência,

falhas temporárias (ex.: Besu reiniciando ou atingindo limite de conexões).

Tarefas:

Localizar a função que chama:

POST http://localhost:8083/api/v1/register-sla


e substituí-la por uma implementação estruturada, por exemplo:

async def register_sla_in_blockchain(payload: dict) -> dict:
    """
    Envia o SLA-aware para o BC-NSSMF e retorna resposta estruturada.
    Deve ser resiliente a falhas transitórias de rede.
    """


Implementar chamadas com:

httpx.AsyncClient dedicado para NASP (ou reusar um client global para NASP);

timeout=5.0 (componente connect + read);

retries (no mínimo 3 tentativas) com backoff simples:

for attempt in range(3):
    try:
        # faz POST
        break
    except (httpx.ConnectError, httpx.ReadTimeout) as e:
        if attempt == 2:
            raise
        await asyncio.sleep(1 * (attempt + 1))


Diferenciar claramente os tipos de erro:

Erro de conexão/timeout:

Logar como: ❌ BC-NSSMF: erro de conexão (provável problema de port-forward ou NASP offline)

O backend deve retornar ao frontend uma mensagem indicando que é problema de conectividade, não de lógica de SLA.

Erro 503 com JSON interno (ex.: {"detail":"BC-NSSMF está em modo degraded. RPC Besu não disponível."}):

Tratar como erro do NASP, mas manter a mensagem original no log.

Erro 4xx (payload inválido):

Tratar como problema de entrada, com mensagem clara para ajuste de geração do SLA-aware.

Garantir que o backend:

Nunca derrube o processo por causa de uma falha do BC-NSSMF;

Sempre retorne uma resposta estruturada ao frontend, com campos do tipo:

{
  "success": false,
  "phase": "blockchain",
  "reason": "connection_error" | "nasp_degraded" | "invalid_payload" | "unknown",
  "detail": "mensagem humana"
}

FASE P4 – FORÇAR O PORTAL A USAR SOMENTE O NASP (SEM LÓGICA LOCAL)

Objetivo: eliminar qualquer código que simule NASP localmente.

Tarefas:

Procurar no backend por palavras-chave como:

mock, fake, stub, demo, local_nasp, offline_mode, NO_BC, etc.

Caso existam funções/rotas que gerem decisões, intents, predições ou registros de SLA sem passar pelo NASP, fazer o seguinte:

Se forem apenas utilitários de teste interno, documentar claramente e desabilitar por padrão (ex.: rotas protegidas por DEBUG).

Se forem usados pelo frontend, avaliar se ainda fazem sentido:

Ideal: remover da rota pública e orientar o frontend a sempre chamar a pipeline real (SEM → ML → DE → BC).

Atualizar a documentação (README do backend) explicando:

Em ambiente TriSLA real, todas as operações de SLA devem passar pelo NASP;

O Portal não é um simulador, é uma “janela” para o NASP.

FASE P5 – HEALTH GLOBAL DO PORTAL (DIAGNÓSTICO AUTOMÁTICO)

Objetivo: iniciar o Portal Light já testando conexão com o NASP e disponibilizar isso para o usuário.

Tarefas:

Melhorar o endpoint já existente /health do backend para incluir um campo indicando se o NASP está acessível ou não, por exemplo:

{
  "status": "ok",
  "version": "x.y.z",
  "nasp_reachable": true,
  "nasp_details_url": "/nasp/diagnostics"
}


Obs.: Não precisa fazer todos os testes no próprio /health para não deixá-lo pesado; ele pode apenas chamar uma versão resumida de nasp_diagnostics ou apenas indicar se o último diagnóstico foi bem-sucedido.

Garantir que, ao iniciar o backend (no startup event do FastAPI), seja feito um primeiro diagnóstico leve:

Testar pelo menos a reachability de SEM-CSMF e BC-NSSMF;

Logar o resultado (INFO ou WARNING).

Se for razoável, criar um pequeno comando utilitário (ex.: python -m src.tools.nasp_check) que rode:

teste rápido de todos endpoints NASP,

imprime um resumo no terminal.

FASE P6 – ALINHAMENTO COM O FRONTEND

Objetivo: garantir que o frontend interprete corretamente os novos erros e estados.

Tarefas:

Identificar onde o frontend consome o resultado do endpoint /api/v1/sla/submit do backend.

Ajustar a lógica para:

Diferenciar erro de conectividade NASP/BC-NSSMF de:

rejeição de SLA pelo Decision Engine,

erro de validação de formulário,

erro de negócio.

Exibir mensagens claras ao usuário, como:

“Falha ao contatar o módulo BC-NSSMF (Blockchain). Verifique se o NASP está acessível.”

“SLA rejeitado pelo mecanismo de decisão. Motivo: ...”

Se houver um painel de status no frontend, acrescentar:

um pequeno indicador de estado “Conexão com NASP: OK / Degradado / Offline”,

consumindo GET /nasp/diagnostics ou /health.

FASE P7 – DOCUMENTAÇÃO E CHECKLIST FINAL

Tarefas:

Criar um arquivo docs/PORTAL_NASP_INTEGRATION.md (ou similar) contendo:

Como subir o NASP no cluster (resumo conceitual, sem detalhes de infra);

Quais port-forwards devem estar ativos no node1;

Quais variáveis de ambiente o Portal usa para conectar ao NASP;

Como interpretar os resultados de /health e /nasp/diagnostics.

No final do documento, incluir um checklist rápido que o usuário pode seguir:

 Port-forwards ativos em node1: 8080–8084

 Backend rodando em localhost:8001

 GET /health retornando status=ok

 GET /nasp/diagnostics com todos os módulos reachable=true

 Envio de um SLA de teste concluindo com:

pipeline SEM → ML → Decision → BC → SLA-Agent

hash de transação registrado no log

CRITÉRIO DE CONCLUSÃO

Considere o trabalho concluído quando:

Todos os endpoints NASP usados pelo Portal forem configuráveis via env e tiverem defaults adequados (localhost:8080–8084).

O endpoint /nasp/diagnostics existir e retornar um resumo claro dos módulos.

A chamada ao /register-sla for:

resiliente (timeouts, retries),

com tratamento adequado de erros,

sem derrubar o backend.

O Portal não depender de lógica local para simular NASP.

A documentação de integração estiver criada e clara.

Quando terminar, produza um resumo das modificações realizadas (arquivos tocados, principais decisões e como testar) no próprio README ou em docs/PORTAL_NASP_INTEGRATION.md.