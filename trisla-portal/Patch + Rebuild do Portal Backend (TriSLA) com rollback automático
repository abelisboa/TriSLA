Objetivo: corrigir o bug “422 → nasp_degraded”, rebuildar imagem do backend com tag nova, aplicar no NASP, validar fim-a-fim e fazer rollback se algo falhar.

FASE 0 — Proteção de contexto (BLOQUEIA SE ERRADO)

Execute exatamente nesta ordem (sem pular).

0.1 — Confirmar que entrou pelo caminho correto

No seu terminal local (WSL/Windows), execute:

hostname
pwd
whoami


Critérios para continuar:

hostname deve mostrar node1 (isso é esperado mesmo entrando via ssh node006)

pwd deve ser abelisboa@DESKTOP-DOLD49V:/mnt/c/Users/USER/Documents/TriSLA-clean (se não, ajuste no passo 0.3)


Se pwd não for exatamente o diretório acima, PARE e corrija antes de seguir.

FASE 1 — Snapshot rápido e pré-checks (não destrutivo)
set -euo pipefail

echo "== CONTEXTO =="
date
kubectl version 2>/dev/null || true
kubectl -n trisla get pods -o wide | egrep "portal-backend|portal-frontend|bc-nssmf|besu" || true

echo "== IMAGEM ATUAL BACKEND =="
kubectl -n trisla get deploy trisla-portal-backend -o=jsonpath='{.spec.template.spec.containers[0].image}{"\n"}' || true


Salvar imagem atual para rollback:

OLD_BACKEND_IMAGE="$(kubectl -n trisla get deploy trisla-portal-backend -o=jsonpath='{.spec.template.spec.containers[0].image}')"
echo "OLD_BACKEND_IMAGE=$OLD_BACKEND_IMAGE"

FASE 2 — Aplicar patch no código (Portal Backend)
2.1 — Localizar o código do backend no repositório

Ajuste os caminhos se o seu repo tiver estrutura diferente; não chute: use find.

cd /home/porvir5g/gtp5g/trisla

echo "== PROCURANDO BACKEND =="
find . -maxdepth 4 -type d | egrep -i "portal|backend" | head -n 50


Agora procure o local do FastAPI (ex.: app/, main.py):

echo "== PROCURANDO main.py / app =="
find . -maxdepth 6 -type f -name "main.py" | egrep -i "portal|backend" || true
find . -maxdepth 6 -type d -name "app" | egrep -i "portal|backend" || true

2.2 — Criar o arquivo app/core/error_mapping.py

Substitua BACKEND_DIR abaixo pelo diretório real encontrado (ex.: ./trisla-portal/backend).

BACKEND_DIR="./trisla-portal/backend"   # <<< AJUSTE AQUI
test -d "$BACKEND_DIR" || (echo "ERRO: BACKEND_DIR não existe: $BACKEND_DIR" && exit 1)

mkdir -p "$BACKEND_DIR/app/core"

cat > "$BACKEND_DIR/app/core/error_mapping.py" << 'PY'
from __future__ import annotations

from typing import Any, Dict, Optional


def map_bc_nssmf_response(*, status_code: int, body: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    body = body or {}

    if 400 <= status_code < 500:
        detail = body.get("detail") or body.get("message") or body
        return {
            "success": False,
            "phase": "blockchain",
            "reason": "business_error",
            "detail": detail,
            "upstream_status": status_code,
        }

    if 500 <= status_code < 600:
        detail = body.get("detail") or body.get("message") or body
        return {
            "success": False,
            "phase": "blockchain",
            "reason": "nasp_degraded",
            "detail": detail or "BC-NSSMF indisponível (erro 5xx).",
            "upstream_status": status_code,
        }

    return {
        "success": False,
        "phase": "blockchain",
        "reason": "nasp_degraded",
        "detail": {"unexpected_status": status_code, "body": body},
        "upstream_status": status_code,
    }
PY

2.3 — Localizar o endpoint /api/v1/sla/submit e aplicar correção
echo "== PROCURANDO sla/submit no backend =="
grep -RIn --line-number "sla/submit" "$BACKEND_DIR/app" || true
grep -RIn --line-number "submit_sla" "$BACKEND_DIR/app" || true
grep -RIn --line-number "register-sla" "$BACKEND_DIR/app" || true


Abra o arquivo encontrado (ex.: .../routes/sla.py) e substitua a lógica atual que transforma “!=200 → nasp_degraded” por esta lógica.

Patch genérico por orientação (edite manualmente com editor do terminal):

TARGET_FILE="$(grep -RIl "sla/submit" "$BACKEND_DIR/app" | head -n 1)"
echo "TARGET_FILE=$TARGET_FILE"
test -n "$TARGET_FILE" || (echo "ERRO: não encontrei arquivo do endpoint sla/submit" && exit 1)

cp -av "$TARGET_FILE" "${TARGET_FILE}.bak.$(date +%Y%m%d_%H%M%S)"

echo "Abra e edite o arquivo agora:"
echo "  nano $TARGET_FILE"

Conteúdo obrigatório a inserir (copiar e colar dentro do arquivo do endpoint)

Dentro do arquivo do endpoint:

Importar:

from app.core.error_mapping import map_bc_nssmf_response
import httpx
from fastapi import HTTPException


Na parte que chama o BC-NSSMF, aplicar:

2xx: retorna normal

4xx: retorna HTTP 422 com reason=business_error

5xx / exceções: retorna HTTP 503 com reason=nasp_degraded

Use o bloco abaixo como referência:

try:
    async with httpx.AsyncClient(timeout=10.0) as client:
        resp = await client.post(bc_url, json=payload)

    if 200 <= resp.status_code < 300:
        return resp.json()

    try:
        body = resp.json()
    except Exception:
        body = {"raw": resp.text}

    mapped = map_bc_nssmf_response(status_code=resp.status_code, body=body)

    if 400 <= resp.status_code < 500:
        raise HTTPException(status_code=422, detail=mapped)

    raise HTTPException(status_code=503, detail=mapped)

except (httpx.ConnectError, httpx.ReadTimeout, httpx.ConnectTimeout) as e:
    raise HTTPException(
        status_code=503,
        detail={
            "success": False,
            "phase": "blockchain",
            "reason": "nasp_degraded",
            "detail": f"Falha de conectividade com BC-NSSMF: {type(e).__name__}",
        },
    )

FASE 3 — Teste local rápido do backend (pytest)

Se o projeto já tem pytest, rode. Se não tiver, pule com registro.

cd "$BACKEND_DIR"

if [ -f "pytest.ini" ] || [ -d "tests" ]; then
  echo "== RODANDO PYTEST =="
  pytest -q || (echo "ERRO: pytest falhou. Corrija antes do build." && exit 1)
else
  echo "== AVISO: sem estrutura de testes detectada (pytest.ini/tests). Seguindo sem pytest."
fi

FASE 4 — Build + Push com TAG NOVA (anti-cache)
4.1 — Escolher nova tag (NUNCA reutilizar)

Defina uma tag nova após v3.7.18 (exemplo: v3.7.19-backend ou v3.7.19 se o padrão for único).
Use uma única tag, sem reuso.

NEW_BACKEND_TAG="v3.7.19"   # <<< AJUSTE AQUI (NOVA TAG)
BACKEND_IMAGE="ghcr.io/abelisboa/trisla-portal-backend:${NEW_BACKEND_TAG}"

echo "BACKEND_IMAGE=$BACKEND_IMAGE"

4.2 — Build e push

Ajuste o caminho do Dockerfile conforme sua árvore.

cd "$BACKEND_DIR"

echo "== BUILD =="
docker build -t "$BACKEND_IMAGE" -t "ghcr.io/abelisboa/trisla-portal-backend:latest" .

echo "== PUSH =="
docker push "$BACKEND_IMAGE"
docker push "ghcr.io/abelisboa/trisla-portal-backend:latest"


Registre o digest (se quiser):

docker inspect --format='{{index .RepoDigests 0}}' "$BACKEND_IMAGE" || true